diff --git a/gui/simple-greeter/gdm-chooser-widget.c b/gui/simple-greeter/gdm-chooser-widget.c
index 102b2c7..689cccc 100644
--- a/gui/simple-greeter/gdm-chooser-widget.c
+++ b/gui/simple-greeter/gdm-chooser-widget.c
@@ -504,7 +504,7 @@ get_normalized_position_of_row_at_path (GdmChooserWidget *widget,
                                                      area_of_visible_rows.y,
                                                      &area_of_visible_rows.x,
                                                      &area_of_visible_rows.y);
-        return ((double) area_of_row_at_path.y) / widget->priv->items_view->allocation.height;
+        return CLAMP (((double) area_of_row_at_path.y) / widget->priv->items_view->allocation.height, 0.0, 1.0);
 }
 
 static void
@@ -603,6 +603,10 @@ skip_resize_animation (GdmChooserWidget *widget)
 static void
 gdm_chooser_widget_grow (GdmChooserWidget *widget)
 {
+        if (widget->priv->state == GDM_CHOOSER_WIDGET_STATE_SHRINKING) {
+                gdm_scrollable_widget_stop_sliding (GDM_SCROLLABLE_WIDGET (widget->priv->scrollable_widget));
+        }
+
         gtk_alignment_set (GTK_ALIGNMENT (widget->priv->frame_alignment),
                            0.0, 0.0, 1.0, 1.0);
 
@@ -651,6 +655,16 @@ gdm_chooser_widget_shrink (GdmChooserWidget *widget)
 {
         g_assert (widget->priv->should_hide_inactive_items == TRUE);
 
+        if (widget->priv->state == GDM_CHOOSER_WIDGET_STATE_GROWING) {
+
+                /* FIXME: since we don't distinguish between a canceled
+                 * animation and a finished one, the next line is going
+                 * to mean at the next size-allocate signal,
+                 * height_when_grown is going to get set to the wrong value
+                 */
+                gdm_scrollable_widget_stop_sliding (GDM_SCROLLABLE_WIDGET (widget->priv->scrollable_widget));
+        }
+
         set_frame_text (widget, widget->priv->active_text);
 
         gtk_alignment_set (GTK_ALIGNMENT (widget->priv->frame_alignment),
diff --git a/gui/simple-greeter/gdm-greeter-login-window.c b/gui/simple-greeter/gdm-greeter-login-window.c
index d7bc7e3..aebeb68 100644
--- a/gui/simple-greeter/gdm-greeter-login-window.c
+++ b/gui/simple-greeter/gdm-greeter-login-window.c
@@ -159,7 +159,10 @@ static void     gdm_greeter_login_window_class_init   (GdmGreeterLoginWindowClas
 static void     gdm_greeter_login_window_init         (GdmGreeterLoginWindow      *greeter_login_window);
 static void     gdm_greeter_login_window_finalize     (GObject                    *object);
 
-static void restart_timed_login_timeout (GdmGreeterLoginWindow *login_window);
+static void     restart_timed_login_timeout (GdmGreeterLoginWindow *login_window);
+static void     on_user_unchosen            (GdmUserChooserWidget *user_chooser,
+                                             GdmGreeterLoginWindow *login_window);
+
 G_DEFINE_TYPE (GdmGreeterLoginWindow, gdm_greeter_login_window, GTK_TYPE_WINDOW)
 
 static void
@@ -228,6 +231,8 @@ set_sensitive (GdmGreeterLoginWindow *login_window,
 
         box = glade_xml_get_widget (login_window->priv->xml, "buttonbox");
         gtk_widget_set_sensitive (box, sensitive);
+
+        gtk_widget_set_sensitive (login_window->priv->user_chooser, sensitive);
 }
 
 static void
@@ -618,7 +623,11 @@ reset_dialog (GdmGreeterLoginWindow *login_window)
         }
         _gdm_greeter_login_window_set_interactive (login_window, FALSE);
 
+        g_signal_handlers_block_by_func (G_OBJECT (login_window->priv->user_chooser),
+                                         G_CALLBACK (on_user_unchosen), login_window);
         gdm_user_chooser_widget_set_chosen_user_name (GDM_USER_CHOOSER_WIDGET (login_window->priv->user_chooser), NULL);
+        g_signal_handlers_unblock_by_func (G_OBJECT (login_window->priv->user_chooser),
+                                           G_CALLBACK (on_user_unchosen), login_window);
 
         if (login_window->priv->start_session_handler_id > 0) {
                 g_signal_handler_disconnect (login_window, login_window->priv->start_session_handler_id);
@@ -635,10 +644,6 @@ reset_dialog (GdmGreeterLoginWindow *login_window)
         label = glade_xml_get_widget (GDM_GREETER_LOGIN_WINDOW (login_window)->priv->xml, "auth-prompt-label");
         gtk_label_set_text (GTK_LABEL (label), "");
 
-        set_message (login_window, "");
-
-        gdm_user_chooser_widget_set_chosen_user_name (GDM_USER_CHOOSER_WIDGET (login_window->priv->user_chooser), NULL);
-
         switch_mode (login_window, MODE_SELECTION);
 
         set_sensitive (login_window, TRUE);
@@ -707,16 +712,30 @@ gdm_greeter_login_window_request_timed_login (GdmGreeterLoginWindow *login_windo
                                               const char            *username,
                                               int                    delay)
 {
+        static gboolean timed_login_already_enabled;
+
         g_return_if_fail (GDM_IS_GREETER_LOGIN_WINDOW (login_window));
 
         g_debug ("GdmGreeterLoginWindow: requested automatic login for user '%s' in %d seconds", username, delay);
 
+        if (login_window->priv->timed_login_username != NULL) {
+                timed_login_already_enabled = TRUE;
+                g_free (login_window->priv->timed_login_username);
+        } else {
+                timed_login_already_enabled = FALSE;
+        }
         login_window->priv->timed_login_username = g_strdup (username);
         login_window->priv->timed_login_delay = delay;
 
-        reset_dialog (login_window);
+        if (login_window->priv->dialog_mode != MODE_SELECTION) {
+                reset_dialog (login_window);
+        }
         gdm_user_chooser_widget_set_show_auto_user (GDM_USER_CHOOSER_WIDGET (login_window->priv->user_chooser), TRUE);
-        gdm_user_chooser_widget_set_chosen_user_name (GDM_USER_CHOOSER_WIDGET (login_window->priv->user_chooser), GDM_USER_CHOOSER_USER_AUTO);
+
+        if (!timed_login_already_enabled) {
+                gdm_user_chooser_widget_set_chosen_user_name (GDM_USER_CHOOSER_WIDGET (login_window->priv->user_chooser),
+                                                              GDM_USER_CHOOSER_USER_AUTO);
+        }
 }
 
 static void
diff --git a/gui/simple-greeter/gdm-scrollable-widget.c b/gui/simple-greeter/gdm-scrollable-widget.c
index 7b716b2..03712fc 100644
--- a/gui/simple-greeter/gdm-scrollable-widget.c
+++ b/gui/simple-greeter/gdm-scrollable-widget.c
@@ -106,6 +106,7 @@ static void
 gdm_scrollable_widget_animation_free (GdmScrollableWidgetAnimation *animation)
 {
         g_object_unref (animation->timer);
+        animation->timer = NULL;
         g_slice_free (GdmScrollableWidgetAnimation, animation);
 }
 
@@ -190,7 +191,13 @@ gdm_scrollable_widget_animation_start (GdmScrollableWidgetAnimation *animation)
         g_signal_connect_swapped (G_OBJECT (animation->timer), "stop",
                                   G_CALLBACK (on_animation_stop),
                                   animation);
-        gdm_timer_start (animation->timer, .50);
+        gdm_timer_start (animation->timer, .5);
+}
+
+static void
+gdm_scrollable_widget_animation_stop (GdmScrollableWidgetAnimation *animation)
+{
+        gdm_timer_stop (animation->timer);
 }
 
 static gboolean
@@ -621,6 +628,18 @@ gdm_scrollable_widget_animations_are_disabled (GdmScrollableWidget *scrollable_w
 }
 
 void
+gdm_scrollable_widget_stop_sliding (GdmScrollableWidget *scrollable_widget)
+{
+        g_return_if_fail (GDM_IS_SCROLLABLE_WIDGET (scrollable_widget));
+
+        if (scrollable_widget->priv->animation != NULL) {
+                gdm_scrollable_widget_animation_stop (scrollable_widget->priv->animation);
+        }
+
+        g_assert (scrollable_widget->priv->animation == NULL);
+}
+
+void
 gdm_scrollable_widget_slide_to_height (GdmScrollableWidget *scrollable_widget,
                                        int                  height,
                                        GdmScrollableWidgetSlideStepFunc step_func,
@@ -634,7 +653,7 @@ gdm_scrollable_widget_slide_to_height (GdmScrollableWidget *scrollable_widget,
         g_return_if_fail (GDM_IS_SCROLLABLE_WIDGET (scrollable_widget));
         widget = GTK_WIDGET (scrollable_widget);
 
-        g_return_if_fail (scrollable_widget->priv->animation == NULL);
+        gdm_scrollable_widget_stop_sliding (scrollable_widget);
 
         input_redirected = gdm_scrollable_redirect_input_to_event_sink (scrollable_widget);
 
@@ -647,6 +666,10 @@ gdm_scrollable_widget_slide_to_height (GdmScrollableWidget *scrollable_widget,
                         done_func (scrollable_widget, done_user_data);
                 }
 
+                if (input_redirected) {
+                        gdm_scrollable_unredirect_input (scrollable_widget);
+                }
+
                 return;
         }
 
diff --git a/gui/simple-greeter/gdm-scrollable-widget.h b/gui/simple-greeter/gdm-scrollable-widget.h
index 7706466..b1a6878 100644
--- a/gui/simple-greeter/gdm-scrollable-widget.h
+++ b/gui/simple-greeter/gdm-scrollable-widget.h
@@ -61,6 +61,7 @@ struct GdmScrollableWidgetClass
 
 GType                  gdm_scrollable_widget_get_type               (void);
 GtkWidget *            gdm_scrollable_widget_new                    (void);
+void                   gdm_scrollable_widget_stop_sliding           (GdmScrollableWidget *widget);
 void                   gdm_scrollable_widget_slide_to_height        (GdmScrollableWidget *widget,
                                                                      int                  height,
                                                                      GdmScrollableWidgetSlideStepFunc step_func,
diff --git a/gui/simple-greeter/gdm-timer.c b/gui/simple-greeter/gdm-timer.c
index d5ca361..4daf588 100644
--- a/gui/simple-greeter/gdm-timer.c
+++ b/gui/simple-greeter/gdm-timer.c
@@ -212,7 +212,10 @@ do_tick (GdmTimer *timer,
         double time_before_tick;
         double tick_duration;
 
+        g_assert (GDM_IS_TIMER (timer));
+
         time_before_tick = current_time;
+        g_object_ref (G_OBJECT (timer));
         g_signal_emit (G_OBJECT (timer), signals[TICK], 0, progress);
 
         current_time = get_current_time ();
@@ -220,7 +223,11 @@ do_tick (GdmTimer *timer,
 
         next_tick = MAX (frequency - tick_duration, 0.0);
         timer->priv->tick_timeout_id = 0;
-        gdm_timer_queue_next_tick (timer, next_tick);
+
+        if (timer->priv->is_started) {
+                gdm_timer_queue_next_tick (timer, next_tick);
+        }
+        g_object_unref (G_OBJECT (timer));
 }
 
 static gboolean
@@ -230,6 +237,8 @@ on_tick_timeout (GdmTimer *timer)
         double current_time;
         double elapsed_time;
 
+        g_assert (GDM_IS_TIMER (timer));
+
         current_time = get_current_time ();
         elapsed_time = current_time - timer->priv->start_time;
         progress = elapsed_time / timer->priv->duration;
@@ -244,15 +253,10 @@ on_tick_timeout (GdmTimer *timer)
 }
 
 static void
-gdm_timer_clear_timeout (GdmTimer *timer)
-{
-        timer->priv->tick_timeout_id = 0;
-}
-
-static void
 gdm_timer_queue_next_tick (GdmTimer *timer,
                            double    when)
 {
+        g_assert (GDM_IS_TIMER (timer));
         if (timer->priv->tick_timeout_id != 0) {
                 return;
         }
@@ -266,14 +270,14 @@ gdm_timer_queue_next_tick (GdmTimer *timer,
                                                            (GSourceFunc)
                                                            on_tick_timeout,
                                                            timer,
-                                                           (GDestroyNotify)
-                                                           gdm_timer_clear_timeout);
+                                                           NULL);
 }
 
 static void
 gdm_timer_set_is_started (GdmTimer *timer,
                           gboolean  is_started)
 {
+        g_assert (GDM_IS_TIMER (timer));
         timer->priv->is_started = is_started;
         g_object_notify (G_OBJECT (timer), "is-started");
 }
@@ -310,7 +314,9 @@ gdm_timer_stop (GdmTimer *timer)
         }
 
         gdm_timer_set_is_started (timer, FALSE);
+        g_object_ref (G_OBJECT (timer));
         g_signal_emit (G_OBJECT (timer), signals[STOP], 0);
+        g_object_unref (G_OBJECT (timer));
 }
 
 gboolean
