diff -up gdm-2.19.5/gui/modules/dwellmouselistener.c.dont-warp-pointer-to-stylus gdm-2.19.5/gui/modules/dwellmouselistener.c
--- gdm-2.19.5/gui/modules/dwellmouselistener.c.dont-warp-pointer-to-stylus	2007-08-06 11:09:49.000000000 -0400
+++ gdm-2.19.5/gui/modules/dwellmouselistener.c	2007-08-06 11:22:18.000000000 -0400
@@ -35,10 +35,6 @@
 
 #include <X11/Xlib.h>
  
-#ifdef HAVE_XINPUT
-#include <X11/extensions/XInput.h>
-#endif
- 
 /*
  * Note that CONFIGFILE will have to be changed to something more generic
  * if this module is ever moved outside of gdm.
@@ -90,14 +86,10 @@ extern char **environ;
 
 static guint enter_signal_id = 0;
 static guint leave_signal_id = 0;
-static int xinput_type_motion = 0;
 
 static Crossings *crossings = NULL;
 static int cross_pos = 0;
 static guint max_crossings = 0;
-static XID *ext_input_devices = NULL;
-static gint ext_device_count = 0;
-static gboolean latch_core_pointer = TRUE;
  
 static void create_event_watcher (void);
 static void load_bindings(gchar *path);
@@ -110,77 +102,6 @@ static gboolean debug_gestures = FALSE;
 BindingType get_binding_type(char c);
 BindingDirection get_binding_direction(char c);
 
-static gboolean
-is_ext_device (XID id)
-{
-	gint i;
-	for (i=0; i < ext_device_count; i++)
-		if (id == ext_input_devices[i])
-			return TRUE;
-
-	if (debug_gestures)
-		syslog (LOG_WARNING, "is-ext-device failed for %d", (int) id);
-
-	return FALSE;
-}
-
-static void
-init_xinput (GdkDisplay *display, GdkWindow *root)
-{
-#ifdef HAVE_XINPUT
-	XEventClass      event_list[40];
-	int              i, j, number = 0, num_devices; 
-	XDeviceInfo  *devices = NULL;
-	XDevice      *device = NULL;
-
-	devices = XListInputDevices (GDK_DISPLAY_XDISPLAY (display),
-		&num_devices);
-
-	if (debug_gestures)
-		syslog (LOG_WARNING, "Checking %d input devices...",
-			num_devices);
-
-	for (i=0; i < num_devices; i++) {
-		if (devices[i].use == IsXExtensionDevice) {
-			device = XOpenDevice (GDK_DISPLAY_XDISPLAY (display),
-				devices[i].id);
-			for (j=0; j < device->num_classes && number < 39; j++) {
-				switch (device->classes[j].input_class) 
-				{
-				case ValuatorClass:
-					DeviceMotionNotify (device, 
-							    xinput_type_motion, 
-							    event_list[number]);
-					number++;
-				default:
-					break;
-				}
-			}
-			++ext_device_count;
-
-			if (ext_input_devices) {
-				ext_input_devices = g_realloc (ext_input_devices,
-					sizeof (XID *) * ext_device_count);
-			} else {
-				ext_input_devices = g_malloc (sizeof (XID *));
-			}
-			ext_input_devices[ext_device_count - 1] = devices[i].id;
-		}
-	}
-
-	if (debug_gestures)
-		syslog (LOG_WARNING, "%d event types available", number);
-
-	if (XSelectExtensionEvent (GDK_WINDOW_XDISPLAY (root), 
-				   GDK_WINDOW_XWINDOW (root),
-				   event_list, number)) {
-		if (debug_gestures)
-			syslog (LOG_WARNING,
-				"Can't select input device events!");
-	}
-#endif
-}
-
 static gchar *
 screen_exec_display_string (GdkScreen *screen, const char *old)
 {
@@ -687,9 +608,6 @@ leave_enter_emission_hook (GSignalInvoca
 					cursor);
 				gdk_cursor_unref (cursor);
 				g_timeout_add (2000, change_cursor_back, NULL);
-				latch_core_pointer = FALSE;
-				/* once we've recognized a gesture, we need to *
-				 * leave the pointer alone */
 				
 				at_name = strstr (action, "#AT_TYPE=");
 				if (at_name != NULL) {
@@ -719,25 +637,6 @@ leave_enter_emission_hook (GSignalInvoca
 	return TRUE;
 }
 
-static GdkFilterReturn
-gestures_filter (GdkXEvent *gdk_xevent,
-		 GdkEvent *event,
-		 gpointer data)
-{
-	XEvent *xevent = (XEvent *)gdk_xevent;
-
-	if (xevent->type == xinput_type_motion) {
-		XDeviceMotionEvent *motion = (XDeviceMotionEvent *) xevent;
-		if ((motion->axes_count < 2) || !is_ext_device (motion->deviceid))
-			return GDK_FILTER_CONTINUE;
-		if (latch_core_pointer)
-		    XWarpPointer (motion->display, None, 
-			      motion->root,
-			      0, 0, 0, 0, motion->axis_data[0], motion->axis_data[1]);
-	}
-       	return GDK_FILTER_CONTINUE;
-}
-
 static void
 create_event_watcher (void)
 {
@@ -758,12 +657,6 @@ create_event_watcher (void)
 		crossings[i].time      = 0;
 	}
 
-	init_xinput (display, 
-		gdk_screen_get_root_window (
-		gdk_display_get_default_screen (display)));
-
-	gdk_window_add_filter (NULL, gestures_filter, NULL);
-
 	/* set up emission hook */
 	gtk_type_class (GTK_TYPE_WIDGET);
 	enter_signal_id = g_signal_lookup ("enter-notify-event", GTK_TYPE_WIDGET);
