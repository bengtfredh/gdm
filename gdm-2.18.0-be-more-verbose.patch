--- gdm-2.18.0/daemon/slave.c.be-more-verbose	2007-04-17 10:17:28.000000000 -0400
+++ gdm-2.18.0/daemon/slave.c	2007-04-17 10:47:30.000000000 -0400
@@ -966,6 +966,8 @@
 static void 
 gdm_screen_init (GdmDisplay *display) 
 {
+
+        gdm_debug ("gdm_screen_init: initializing xinerama, etc");
 #ifdef HAVE_XFREE_XINERAMA
 	int (* old_xerror_handler) (Display *, XErrorEvent *);
 	gboolean have_xinerama = FALSE;
@@ -982,36 +984,52 @@
 		have_xinerama = FALSE;
 
 	if (have_xinerama) {
+                gdm_debug ("gdm_screen_init: machine has xinerama");
 		int screen_num;
 		int xineramascreen;
 		XineramaScreenInfo *xscreens =
 			XineramaQueryScreens (display->dsp,
 					      &screen_num);
 
+                gdm_debug ("gdm_screen_init: display %s has %d screens", display->name, screen_num);
 
 		if G_UNLIKELY (screen_num <= 0)
 			gdm_fail ("Xinerama active, but <= 0 screens?");
 
 		if (screen_num <= gdm_get_value_int (GDM_KEY_XINERAMA_SCREEN))
+                  {
+                        gdm_debug ("gdm_screen_init: xinerama screen key is bogus (%d when screen_num is %d)",
+                                   gdm_get_value_int (GDM_KEY_XINERAMA_SCREEN), screen_num);
 			gdm_set_value_int (GDM_KEY_XINERAMA_SCREEN, 0);
+                  }
 
 		xineramascreen = gdm_get_value_int (GDM_KEY_XINERAMA_SCREEN);
+                gdm_debug ("gdm_screen_init: using head %d", screen_num);
 
 		display->screenx = xscreens[xineramascreen].x_org;
 		display->screeny = xscreens[xineramascreen].y_org;
 		display->screenwidth = xscreens[xineramascreen].width;
 		display->screenheight = xscreens[xineramascreen].height;
 
+                gdm_debug ("gdm_screen_init: head %d has dimensions (%dx%d+%d+%d)", 
+                           display->screenwidth, display->screenheight,
+                           display->screenx, display->screeny);
+
 		display->lrh_offsetx =
 			DisplayWidth (display->dsp,
 				      DefaultScreen (display->dsp))
 			- (display->screenx + display->screenwidth);
+
+                gdm_debug ("gdm_screen_init: display->lrh_offsetx = %d\n", display->lrh_offsetx);
 		display->lrh_offsety =
 			DisplayHeight (display->dsp,
 				       DefaultScreen (display->dsp))
 			- (display->screeny + display->screenheight);
+                gdm_debug ("gdm_screen_init: display->lrh_offsety = %d\n", display->lrh_offsety);
 
 		XFree (xscreens);
+
+                gdm_debug ("gdm_screen_init: xinerama configured\n");
 	} else
 #elif HAVE_SOLARIS_XINERAMA
  /* This code from GDK, Copyright (C) 2002 Sun Microsystems */
@@ -1034,6 +1052,7 @@
 		unsigned char  hints[16];
 		int xineramascreen;
 		
+                gdm_debug ("gdm_screen_init: machine has sun xinerama");
 		result = XineramaGetInfo (display->dsp, 0, monitors, hints, &n_monitors);
 		/* Yes I know it should be Success but the current implementation 
 		 * returns the num of monitor
@@ -1062,6 +1081,8 @@
 	} else
 #endif
 	{
+
+                gdm_debug ("gdm_screen_init: machine doesn't have xinerama");
 		display->screenx = 0;
 		display->screeny = 0;
 		display->screenwidth = 0; /* we'll use the gdk size */
@@ -1412,6 +1433,7 @@
     else
 	    maxtries = 10;
     
+    gdm_debug ("gdm_slave_run: maxtries = %d\n", maxtries);
     while (d->handled &&
 	   openretries < maxtries &&
 	   d->dsp == NULL &&
@@ -1428,9 +1450,11 @@
 	}
     }
 
+    gdm_debug ("gdm_slave_run: display %s is now open\n", d->name);
     /* Really this will only be useful for the first local server,
        since that's the only time this can really be on */
     while G_UNLIKELY (gdm_wait_for_go) {
+            gdm_debug ("gdm_slave_run: blocking until told to continue\n");
 	    struct timeval tv;
 	    /* Wait 1 second. */
 	    tv.tv_sec = 1;
@@ -1443,6 +1467,7 @@
 
     /* Set the busy cursor */
     if (d->dsp != NULL) {
+            gdm_debug ("gdm_slave_run: settings a busy cursor\n");
 	    Cursor xcursor = XCreateFontCursor (d->dsp, GDK_WATCH);
 	    XDefineCursor (d->dsp,
 			   DefaultRootWindow (d->dsp),
@@ -1451,20 +1476,24 @@
 	    XSync (d->dsp, False);
     }
 
+    gdm_debug ("gdm_slave_run: pausing for no reason at all\n");
     /* Just a race avoiding sleep, probably not necessary though,
      * but doesn't hurt anything */
     if ( ! d->handled)
 	    gdm_sleep_no_signal (1);
 
     if (SERVER_IS_LOCAL (d)) {
+            gdm_debug ("gdm_slave_run: display %s is local\n", d->name);
 	    gdm_slave_send (GDM_SOP_START_NEXT_LOCAL, FALSE);
     }
 
+    gdm_debug ("gdm_slave_run: checking pending notifies\n");
     check_notifies_now ();
 
     /* something may have gone wrong, try xfailed, if local (non-flexi),
      * the toplevel loop of death will handle us */ 
     if G_UNLIKELY (d->handled && d->dsp == NULL) {
+            gdm_debug ("gdm_slave_run: d->dsp is NULL\n");
 	    if (d->type == TYPE_STATIC)
 		    gdm_slave_quick_exit (DISPLAY_XFAILED);
 	    else
@@ -1477,6 +1506,7 @@
 
     /* If XDMCP setup pinging */
     if ( ! SERVER_IS_LOCAL (d) && pinginterval > 0) {
+            gdm_debug ("gdm_slave_run: installing a ping alarm at interval %d\n", pinginterval);
 	    alarm (pinginterval);
     }
 
@@ -1492,17 +1522,27 @@
 
     /* check log stuff for the server, this is done here
      * because it's really a race */
+
     if (SERVER_IS_LOCAL (d))
+      {
+            gdm_debug ("gdm_slave_run: checklog for vt");
 	    gdm_server_checklog (d);
+      }
 
     if ( ! d->handled) {
+
+            gdm_debug ("gdm_slave_run: !d->handled and servpid = %d", d->servpid);
 	    /* yay, we now wait for the server to die */
 	    while (d->servpid > 0) {
+                    gdm_debug ("gdm_slave_run: waiting for signal");
 		    pause ();
 	    }
+
+            gdm_debug ("gdm_slave_run: quick exit");
 	    gdm_slave_quick_exit (DISPLAY_REMANAGE);
     } else if (d->use_chooser) {
 	    /* this usually doesn't return */
+            gdm_debug ("gdm_slave_run: running chooser");
 	    gdm_slave_chooser ();  /* Run the chooser */
 	    return;
     } else if (d->type == TYPE_STATIC &&
@@ -1511,6 +1551,7 @@
 	       strcmp (ParsedAutomaticLogin, gdm_root_user ()) != 0) {
 	    gdm_first_login = FALSE;
 
+            gdm_debug ("gdm_slave_run: starting automatic login");
 	    d->logged_in = TRUE;
 	    gdm_slave_send_num (GDM_SOP_LOGGED_IN, TRUE);
 	    gdm_slave_send_string (GDM_SOP_LOGIN, ParsedAutomaticLogin);
@@ -1540,9 +1581,12 @@
 	    gdm_first_login = FALSE;
 
     do {
+
+            gdm_debug ("gdm_slave_run: checking notifies");
 	    check_notifies_now ();
 
 	    if ( ! greet) {
+                    gdm_debug ("gdm_slave_run: starting greeter");
 		    gdm_slave_greeter ();  /* Start the greeter */
 		    greeter_no_focus = FALSE;
 		    greeter_disabled = FALSE;
