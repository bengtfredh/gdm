From 6e26045943d27656b4444e157d0d10c025aa69db Mon Sep 17 00:00:00 2001
From: Alexander Larsson <alexl@redhat.com>
Date: Thu, 18 Jun 2015 11:57:12 +0200
Subject: [PATCH 1/2] gdm-common: Add gdm_shell_expand() and tests

This allows shell-like expansion of strings. It will be later
used to allow configuring the environment via config files.

https://bugzilla.gnome.org/show_bug.cgi?id=751158
---
 common/gdm-common.c |  87 +++++++++++++++++++++++++++++++++++++++++
 common/gdm-common.h |   9 +++++
 tests/Makefile.am   |   2 +
 tests/m-common.c    |  11 ++++++
 tests/s-common.c    | 110 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 tests/s-common.h    |  28 +++++++++++++
 6 files changed, 247 insertions(+)
 create mode 100644 tests/s-common.c
 create mode 100644 tests/s-common.h

diff --git a/common/gdm-common.c b/common/gdm-common.c
index 5beeebf..a96b30f 100644
--- a/common/gdm-common.c
+++ b/common/gdm-common.c
@@ -710,3 +710,90 @@ gdm_run_script (const char *dir,
 
         return ret;
 }
+
+gboolean
+gdm_shell_var_is_valid_char (gchar c, gboolean first)
+{
+        return (!first && g_ascii_isdigit (c)) ||
+                c == '_' ||
+                g_ascii_isalpha (c);
+}
+
+/* This expands a string somewhat similar to how a shell would do it
+   if it was enclosed inside double quotes.  It handles variable
+   expansion like $FOO and ${FOO}, single-char escapes using \, and
+   non-escaped # at the begining of a word is taken as a comment and ignored */
+char *
+gdm_shell_expand (const char *str,
+                  GdmExpandVarFunc expand_var_func,
+                  gpointer user_data)
+{
+        GString *s = g_string_new("");
+        const gchar *p, *start;
+        gchar c;
+        gboolean at_new_word;
+
+        p = str;
+        at_new_word = TRUE;
+        while (*p) {
+                c = *p;
+                if (c == '\\') {
+                        p++;
+                        c = *p;
+                        if (c != '\0') {
+                                p++;
+                                switch (c) {
+                                case '\\':
+                                        g_string_append_c (s, '\\');
+                                        break;
+                                case '$':
+                                        g_string_append_c (s, '$');
+                                        break;
+                                case '#':
+                                        g_string_append_c (s, '#');
+                                        break;
+                                default:
+                                        g_string_append_c (s, '\\');
+                                        g_string_append_c (s, c);
+                                        break;
+                                }
+                        }
+                } else if (c == '#' && at_new_word) {
+                        break;
+                } else if (c == '$') {
+                        gboolean brackets = FALSE;
+                        p++;
+                        if (*p == '{') {
+                                brackets = TRUE;
+                                p++;
+                        }
+                        start = p;
+                        while (*p != '\0' &&
+                               gdm_shell_var_is_valid_char (*p, p == start))
+                                p++;
+                        if (p == start || (brackets && *p != '}')) {
+                                /* Invalid variable, use as-is */
+                                g_string_append_c (s, '$');
+                                if (brackets)
+                                        g_string_append_c (s, '{');
+                                g_string_append_len (s, start, p - start);
+                        } else {
+                                gchar *expanded;
+                                gchar *var = g_strndup (start, p - start);
+                                if (brackets && *p == '}')
+                                        p++;
+
+                                expanded = expand_var_func (var, user_data);
+                                if (expanded)
+                                        g_string_append (s, expanded);
+                                g_free (var);
+                                g_free (expanded);
+                        }
+                } else {
+                        p++;
+                        g_string_append_c (s, c);
+                        at_new_word = g_ascii_isspace (c);
+                }
+        }
+        return g_string_free (s, FALSE);
+}
diff --git a/common/gdm-common.h b/common/gdm-common.h
index 3302afe..d0812ed 100644
--- a/common/gdm-common.h
+++ b/common/gdm-common.h
@@ -36,6 +36,9 @@
 GQuark gdm_common_error_quark (void);
 #define GDM_COMMON_ERROR gdm_common_error_quark()
 
+typedef char * (*GdmExpandVarFunc) (const char *var,
+                                    gpointer user_data);
+
 G_BEGIN_DECLS
 
 int            gdm_wait_on_pid           (int pid);
@@ -64,6 +67,12 @@ gboolean       gdm_run_script             (const char *dir,
                                            const char *display_hostname,
                                            const char *display_x11_authority_file);
 
+gboolean      gdm_shell_var_is_valid_char (char c,
+                                           gboolean first);
+char *        gdm_shell_expand            (const char *str,
+                                           GdmExpandVarFunc expand_func,
+                                           gpointer user_data);
+
 G_END_DECLS
 
 #endif /* _GDM_COMMON_H */
diff --git a/tests/Makefile.am b/tests/Makefile.am
index 63fc198..c6475af 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -21,6 +21,8 @@ m_common_SOURCES =		\
 	m-common.c		\
 	s-common-address.c	\
 	s-common-address.h	\
+	s-common.c		\
+	s-common.h		\
 	$(NULL)
 
 m_common_CFLAGS =		\
diff --git a/tests/m-common.c b/tests/m-common.c
index c5ff2f4..62f1f44 100644
--- a/tests/m-common.c
+++ b/tests/m-common.c
@@ -24,6 +24,7 @@
 #include <glib-object.h>
 
 #include "s-common-address.h"
+#include "s-common.h"
 
 static gboolean no_fork = FALSE;
 static gboolean verbose = FALSE;
@@ -66,5 +67,15 @@ main (int argc, char **argv)
         failed = srunner_ntests_failed (r);
         srunner_free (r);
 
+        r = srunner_create (suite_common ());
+
+        if (no_fork) {
+                srunner_set_fork_status (r, CK_NOFORK);
+        }
+
+        srunner_run_all (r, verbose ? CK_VERBOSE : CK_NORMAL);
+        failed |= srunner_ntests_failed (r);
+        srunner_free (r);
+
         return failed != 0;
 }
diff --git a/tests/s-common.c b/tests/s-common.c
new file mode 100644
index 0000000..c91306f
--- /dev/null
+++ b/tests/s-common.c
@@ -0,0 +1,110 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andrew Ziem <ahz001@gmail.com>
+ * Copyright (C) 2007 William Jon McCann <mccann@jhu.edu>
+ * Copyright (C) 2015 Alexander Larsson <alexl@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <glib.h>
+#include <check.h>
+
+#include "gdm-common.h"
+#include "s-common.h"
+
+static void
+setup (void)
+{
+}
+
+static void
+teardown (void)
+{
+}
+
+static char *
+expand_fn (const char *var, gpointer data)
+{
+        if (strcmp (var, "FOO") == 0)
+                return g_strdup ("BAR");
+        if (strcmp (var, "FOO9") == 0)
+                return g_strdup ("XXX");
+        if (strcmp (var, "_FOO") == 0)
+                return g_strdup ("YYY");
+        if (strcmp (var, "FOO_FOO") == 0)
+                return g_strdup ("ZZZ");
+        return NULL;
+}
+
+static gboolean expands_to (const char *to_expand, const char *expanded)
+{
+        return strcmp (gdm_shell_expand (to_expand, expand_fn, NULL), expanded) == 0;
+}
+
+START_TEST (test_gdm_shell_expand)
+{
+        fail_unless (expands_to ("foo", "foo"));
+        fail_unless (expands_to ("foo ", "foo "));
+        fail_unless (expands_to ("foo#bar", "foo#bar"));
+        fail_unless (expands_to ("foo #bar", "foo "));
+        fail_unless (expands_to ("#bar", ""));
+        fail_unless (expands_to ("foo #bar gazonk", "foo "));
+        fail_unless (expands_to ("foo #bar gazonk", "foo "));
+        fail_unless (expands_to ("foo #bar gazonk", "foo "));
+        fail_unless (expands_to ("$FOO", "BAR"));
+        fail_unless (expands_to ("$9FOO", "$9FOO"));
+        fail_unless (expands_to ("$FOO9", "XXX"));
+        fail_unless (expands_to ("${FOO}9", "BAR9"));
+        fail_unless (expands_to ("$_FOO", "YYY"));
+        fail_unless (expands_to ("$FOO_FOO", "ZZZ"));
+        fail_unless (expands_to ("${FOO}", "BAR"));
+        fail_unless (expands_to ("$FOO$FOO", "BARBAR"));
+        fail_unless (expands_to ("${FOO}${FOO}", "BARBAR"));
+        fail_unless (expands_to ("$FOO${FOO}", "BARBAR"));
+        fail_unless (expands_to ("$foo", ""));
+        fail_unless (expands_to ("$FOOBAR", ""));
+        fail_unless (expands_to ("$FOO/BAR", "BAR/BAR"));
+        fail_unless (expands_to ("${FOO}BAR", "BARBAR"));
+        fail_unless (expands_to ("$/BAR", "$/BAR"));
+        fail_unless (expands_to ("${FOO BAR}BAR", "${FOO BAR}BAR"));
+        fail_unless (expands_to ("${}BAR", "${}BAR"));
+        fail_unless (expands_to ("${$FOO}BAR", "${BAR}BAR"));
+        fail_unless (expands_to ("\\$foo", "$foo"));
+        fail_unless (expands_to ("a\\\\b", "a\\b"));
+        fail_unless (expands_to ("a\\b", "a\\b"));
+        fail_unless (expands_to ("a\\#b", "a#b"));
+}
+END_TEST
+
+Suite *
+suite_common (void)
+{
+        Suite *s;
+        TCase *tc_core;
+
+        s = suite_create ("gdm-common");
+        tc_core = tcase_create ("core");
+
+        tcase_add_checked_fixture (tc_core, setup, teardown);
+        tcase_add_test (tc_core, test_gdm_shell_expand);
+        suite_add_tcase (s, tc_core);
+
+        return s;
+}
diff --git a/tests/s-common.h b/tests/s-common.h
new file mode 100644
index 0000000..561186f
--- /dev/null
+++ b/tests/s-common.h
@@ -0,0 +1,28 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2015 Alexander Larsson <alexl@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __S_COMMON_H
+#define __S_COMMON_H
+
+#include <check.h>
+
+Suite   *suite_common                 (void);
+
+#endif /* __S_COMMON_H */
-- 
2.4.3

From a5c74b3695244733fc06f1724a91e8f44f6b219e Mon Sep 17 00:00:00 2001
From: Alexander Larsson <alexl@redhat.com>
Date: Thu, 18 Jun 2015 14:03:23 +0200
Subject: [PATCH 2/2] load env.d/*.env files and set in session environment

This loads key-value files from /usr/share/gdm/env.d/*.env and
/etc/gdm/env.d/*.env (in alphabetical filename order) and sets
in the session environment.

https://bugzilla.gnome.org/show_bug.cgi?id=751158
---
 daemon/gdm-session-worker.c | 128 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 128 insertions(+)

diff --git a/daemon/gdm-session-worker.c b/daemon/gdm-session-worker.c
index 6ed6d6c..5ae5b3f 100644
--- a/daemon/gdm-session-worker.c
+++ b/daemon/gdm-session-worker.c
@@ -1355,6 +1355,130 @@ _lookup_passwd_info (const char *username,
         return ret;
 }
 
+static char *
+get_var_cb (const char *key,
+            gpointer user_data)
+{
+        return gdm_session_worker_get_environment_variable (user_data, key);
+}
+
+static void
+load_env_file (GdmSessionWorker *worker,
+               GFile   *file)
+{
+        gchar *contents;
+        gchar **lines;
+        gchar *line, *p;
+        gchar *var, *var_end;
+        gchar *expanded;
+        char *filename;
+        int i;
+
+        filename = g_file_get_path (file);
+        g_debug ("Loading env vars from %s\n", filename);
+        g_free (filename);
+
+        if (g_file_load_contents (file, NULL, &contents, NULL, NULL, NULL)) {
+                lines = g_strsplit (contents, "\n", -1);
+                g_free (contents);
+                for (i = 0; lines[i] != NULL; i++) {
+                        line = lines[i];
+                        p = line;
+                        while (g_ascii_isspace (*p))
+                                p++;
+                        if (*p == '#' || *p == '\0')
+                                continue;
+                        var = p;
+                        while (gdm_shell_var_is_valid_char (*p, p == var))
+                                p++;
+                        var_end = p;
+                        while (g_ascii_isspace (*p))
+                                p++;
+                        if (var == var_end || *p != '=') {
+                                g_warning ("Invalid env.d line '%s'\n", line);
+                                continue;
+                        }
+                        *var_end = 0;
+                        p++; /* Skip = */
+                        while (g_ascii_isspace (*p))
+                                p++;
+
+                        expanded = gdm_shell_expand (p, get_var_cb, worker);
+                        expanded = g_strchomp (expanded);
+                        gdm_session_worker_set_environment_variable (worker, var, expanded);
+                        g_free (expanded);
+                }
+                g_strfreev (lines);
+        }
+}
+
+static gint
+compare_str (gconstpointer  a,
+             gconstpointer  b)
+{
+  return strcmp (*(const char **)a, *(const char **)b);
+}
+
+static void
+gdm_session_worker_load_env_dir (GdmSessionWorker *worker,
+                                 GFile *dir)
+{
+        GFileInfo *info = NULL;
+        GFileEnumerator *enumerator = NULL;
+        GPtrArray *names = NULL;
+        GFile *file;
+        const gchar *name;
+        int i;
+
+        enumerator = g_file_enumerate_children (dir,
+                                                G_FILE_ATTRIBUTE_STANDARD_TYPE","
+                                                G_FILE_ATTRIBUTE_STANDARD_NAME","
+                                                G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN","
+                                                G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP,
+                                                G_FILE_QUERY_INFO_NONE,
+                                                NULL, NULL);
+        if (!enumerator) {
+                goto out;
+        }
+
+        names = g_ptr_array_new_with_free_func (g_free);
+        while ((info = g_file_enumerator_next_file (enumerator, NULL, NULL)) != NULL) {
+                if (g_file_info_get_file_type (info) == G_FILE_TYPE_REGULAR &&
+                    !g_file_info_get_is_hidden (info) &&
+                    g_str_has_suffix (g_file_info_get_name (info), ".env"))
+                  g_ptr_array_add (names, g_strdup (g_file_info_get_name (info)));
+
+                g_clear_object (&info);
+        }
+
+        g_ptr_array_sort (names, compare_str);
+
+        for (i = 0; i < names->len; i++) {
+                name = g_ptr_array_index (names, i);
+                file = g_file_get_child (dir, name);
+                load_env_file (worker, file);
+                g_object_unref (file);
+        }
+
+ out:
+        g_clear_pointer (&names, g_ptr_array_unref);
+        g_clear_object (&enumerator);
+}
+
+static void
+gdm_session_worker_load_env_d (GdmSessionWorker *worker)
+{
+        GFile *dir;
+
+        dir = g_file_new_for_path (DATADIR "/gdm/env.d");
+        gdm_session_worker_load_env_dir (worker, dir);
+        g_object_unref (dir);
+
+        dir = g_file_new_for_path (GDMCONFDIR "/env.d");
+        gdm_session_worker_load_env_dir (worker, dir);
+        g_object_unref (dir);
+}
+
 static gboolean
 gdm_session_worker_accredit_user (GdmSessionWorker  *worker,
                                   GError           **error)
@@ -1762,6 +1886,10 @@ gdm_session_worker_start_session (GdmSessionWorker  *worker,
                 }
 #endif
 
+                if (!worker->priv->is_program_session) {
+                        gdm_session_worker_load_env_d (worker);
+                }
+
                 environment = gdm_session_worker_get_environment (worker);
 
                 g_assert (geteuid () == getuid ());
-- 
2.4.3

