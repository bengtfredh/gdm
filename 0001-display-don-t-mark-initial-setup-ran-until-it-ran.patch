From 10cde6a7f6a02db0b98bb8a2790ba55b3cd17eb0 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Mon, 23 Oct 2017 15:03:42 -0400
Subject: [PATCH] display: don't mark initial-setup ran until it ran

We don't want to skip running initial setup if wayland
fell back or something.

This commit makes sure we only stop trying to start initial-setup
after it's completed.
---
 daemon/gdm-display.c | 22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

diff --git a/daemon/gdm-display.c b/daemon/gdm-display.c
index 1f1ecb6d..6a3984a9 100644
--- a/daemon/gdm-display.c
+++ b/daemon/gdm-display.c
@@ -1438,70 +1438,60 @@ on_launch_environment_session_died (GdmLaunchEnvironment *launch_environment,
                                     GdmDisplay           *self)
 {
         g_debug ("GdmDisplay: Greeter died: %d", signal);
         self_destruct (self);
 }
 
 static gboolean
 can_create_environment (const char *session_id)
 {
         char *path;
         gboolean session_exists;
 
         path = g_strdup_printf (GNOME_SESSION_SESSIONS_PATH "/%s.session", session_id);
         session_exists = g_file_test (path, G_FILE_TEST_EXISTS);
 
         g_free (path);
 
         return session_exists;
 }
 
 #define ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT GDM_RUN_DIR "/gdm.ran-initial-setup"
 
 static gboolean
 already_done_initial_setup_on_this_boot (void)
 {
         GError *error = NULL;
 
         if (g_file_test (ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT, G_FILE_TEST_EXISTS))
                 return TRUE;
 
-        if (!g_file_set_contents (ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT,
-                                  "1",
-                                  1,
-                                  &error)) {
-                g_warning ("GdmDisplay: Could not write initial-setup-done marker to %s: %s",
-                           ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT,
-                           error->message);
-                g_clear_error (&error);
-        }
-
         return FALSE;
 }
 
 static gboolean
 kernel_cmdline_initial_setup_argument (const gchar  *contents,
                                        gchar       **initial_setup_argument,
                                        GError      **error)
 {
         GRegex *regex = NULL;
         GMatchInfo *match_info = NULL;
         gchar *match_group = NULL;
 
         g_return_val_if_fail (initial_setup_argument != NULL, FALSE);
 
         regex = g_regex_new ("\\bgnome.initial-setup=([^\\s]*)\\b", 0, 0, error);
 
         if (!regex)
             return FALSE;
 
         if (!g_regex_match (regex, contents, 0, &match_info)) {
                 g_free (match_info);
                 g_free (regex);
 
                 g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
                              "Could not match gnome.initial-setup= in kernel cmdline");
 
                 return FALSE;
         }
 
         match_group = g_match_info_fetch (match_info, 1);
@@ -1692,83 +1682,95 @@ chown_initial_setup_home_dir (void)
                                          "gnome-initial-setup-uid",
                                          NULL);
         if (!g_file_get_contents (gis_uid_path, &gis_uid_contents, NULL, NULL)) {
                 g_warning ("Unable to read %s", gis_uid_path);
                 goto out;
         }
 
         uid = (uid_t) atoi (gis_uid_contents);
         pwe = getpwuid (uid);
         if (uid == 0 || pwe == NULL) {
                 g_warning ("UID '%s' in %s is not valid", gis_uid_contents, gis_uid_path);
                 goto out;
         }
 
         error = NULL;
         dir = g_file_new_for_path (gis_dir_path);
         if (!chown_recursively (dir, pwe->pw_uid, pwe->pw_gid, &error)) {
                 g_warning ("Failed to change ownership for %s: %s", gis_dir_path, error->message);
                 g_error_free (error);
         }
         g_object_unref (dir);
 out:
         g_free (gis_uid_contents);
         g_free (gis_uid_path);
         g_free (gis_dir_path);
 }
 
 void
 gdm_display_stop_greeter_session (GdmDisplay *self)
 {
+        GError *error = NULL;
+
         if (self->priv->launch_environment != NULL) {
 
                 g_signal_handlers_disconnect_by_func (self->priv->launch_environment,
                                                       G_CALLBACK (on_launch_environment_session_opened),
                                                       self);
                 g_signal_handlers_disconnect_by_func (self->priv->launch_environment,
                                                       G_CALLBACK (on_launch_environment_session_started),
                                                       self);
                 g_signal_handlers_disconnect_by_func (self->priv->launch_environment,
                                                       G_CALLBACK (on_launch_environment_session_stopped),
                                                       self);
                 g_signal_handlers_disconnect_by_func (self->priv->launch_environment,
                                                       G_CALLBACK (on_launch_environment_session_exited),
                                                       self);
                 g_signal_handlers_disconnect_by_func (self->priv->launch_environment,
                                                       G_CALLBACK (on_launch_environment_session_died),
                                                       self);
                 gdm_launch_environment_stop (self->priv->launch_environment);
                 g_clear_object (&self->priv->launch_environment);
         }
 
         if (self->priv->doing_initial_setup) {
                 chown_initial_setup_home_dir ();
+
+                if (!g_file_set_contents (ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT,
+                                          "1",
+                                          1,
+                                          &error)) {
+                        g_warning ("GdmDisplay: Could not write initial-setup-done marker to %s: %s",
+                                   ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT,
+                                   error->message);
+                        g_clear_error (&error);
+                }
         }
 }
 
 static xcb_window_t
 get_root_window (xcb_connection_t *connection,
                  int               screen_number)
 {
         xcb_screen_t *screen = NULL;
         xcb_screen_iterator_t iter;
 
         iter = xcb_setup_roots_iterator (xcb_get_setup (connection));
         while (iter.rem) {
                 if (screen_number == 0)
                         screen = iter.data;
                 screen_number--;
                 xcb_screen_next (&iter);
         }
 
         if (screen != NULL) {
                 return screen->root;
         }
 
         return XCB_WINDOW_NONE;
 }
 
 static void
 gdm_display_set_windowpath (GdmDisplay *self)
 {
         /* setting WINDOWPATH for clients */
         xcb_intern_atom_cookie_t atom_cookie;
-- 
2.14.2

