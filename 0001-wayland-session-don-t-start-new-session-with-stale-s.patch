From e39d4dacfab25ff4500cbd4dae89d1882d7491dd Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 21 Sep 2016 15:38:02 -0400
Subject: [PATCH] wayland-session: don't start new session with stale session
 env vars

commit 448134d3cdbc54e5359ea33d387993b0defdaefa changed gdm to
import the session from systemd --user.

Unfortunately, it broke log in after log out. The problem is, certain
session specific environment variables from the previous session
were getting leaked into the new session.

This commit wipes the ones causing the most problems on the GDM side,
but gnome-session should also probably purge them from the systemd
--user environment when it exits.
---
 daemon/gdm-wayland-session.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/daemon/gdm-wayland-session.c b/daemon/gdm-wayland-session.c
index 503c398..8b0e56a 100644
--- a/daemon/gdm-wayland-session.c
+++ b/daemon/gdm-wayland-session.c
@@ -291,60 +291,67 @@ spawn_session (State        *state,
         if (!ret) {
                 g_debug ("could not parse session arguments: %s", error->message);
                 goto out;
         }
 
         launcher = g_subprocess_launcher_new (G_SUBPROCESS_FLAGS_NONE);
 
         if (state->environment != NULL) {
                 size_t i;
 
                 for (i = 0; state->environment[i] != NULL; i++) {
                         g_auto(GStrv) environment_entry = NULL;
 
                         if (state->environment[i] == '\0') {
                                 continue;
                         }
 
                         environment_entry = g_strsplit (state->environment[i], "=", 2);
 
                         if (environment_entry[0] == NULL || environment_entry[1] == NULL) {
                                 continue;
                         }
 
                         g_subprocess_launcher_setenv (launcher, environment_entry[0], environment_entry[1], FALSE);
                 }
         }
 
         if (state->bus_address != NULL) {
                 g_subprocess_launcher_setenv (launcher, "DBUS_SESSION_BUS_ADDRESS", state->bus_address, TRUE);
         }
+
+        /* Don't allow session specific environment variables from earlier sessions to leak through */
+        g_subprocess_launcher_unsetenv (launcher, "DISPLAY");
+        g_subprocess_launcher_unsetenv (launcher, "XAUTHORITY");
+        g_subprocess_launcher_unsetenv (launcher, "WAYLAND_DISPLAY");
+        g_subprocess_launcher_unsetenv (launcher, "WAYLAND_SOCKET");
+
         subprocess = g_subprocess_launcher_spawnv (launcher,
                                                    (const char * const *) argv,
                                                    &error);
         g_strfreev (argv);
 
         if (subprocess == NULL) {
                 g_debug ("could not start session: %s", error->message);
                 goto out;
         }
 
         state->session_subprocess = g_object_ref (subprocess);
 
         g_subprocess_wait_async (state->session_subprocess,
                                  cancellable,
                                  (GAsyncReadyCallback)
                                  on_session_finished,
                                  state);
 
         is_running = TRUE;
 out:
         g_clear_object (&subprocess);
         return is_running;
 }
 
 static void
 signal_subprocesses (State *state)
 {
         if (state->session_subprocess != NULL) {
                 g_subprocess_send_signal (state->session_subprocess, SIGTERM);
         }
-- 
2.9.3

