From c46f1f6798088c4d0ebc809fe200e2fee50d69f6 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Mon, 23 Mar 2015 08:46:40 -0400
Subject: [PATCH 1/2] Revert "manager: add hack to quit plymouth after a delay"

This reverts commit 862ba1bd67ec85b5784d3e8809a405f1845b1c43.

https://bugzilla.gnome.org/show_bug.cgi?id=746498
---
 daemon/gdm-manager.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/daemon/gdm-manager.c b/daemon/gdm-manager.c
index e9ed29d..8c36e06 100644
--- a/daemon/gdm-manager.c
+++ b/daemon/gdm-manager.c
@@ -162,61 +162,61 @@ plymouth_is_running (void)
                 g_debug ("Could not ping plymouth: %s", error->message);
                 g_error_free (error);
                 return FALSE;
         }
 
         return WIFEXITED (status) && WEXITSTATUS (status) == 0;
 }
 
 static void
 plymouth_prepare_for_transition (void)
 {
         gboolean res;
         GError  *error;
 
         error = NULL;
         res = g_spawn_command_line_sync ("/bin/plymouth deactivate",
                                          NULL, NULL, NULL, &error);
         if (! res) {
                 g_warning ("Could not deactivate plymouth: %s", error->message);
                 g_error_free (error);
         }
 }
 
 static void
 plymouth_quit_with_transition (void)
 {
         gboolean res;
         GError  *error;
 
         error = NULL;
-        res = g_spawn_command_line_async ("sleep 2; /bin/plymouth quit --retain-splash", &error);
+        res = g_spawn_command_line_async ("/bin/plymouth quit --retain-splash", &error);
         if (! res) {
                 g_warning ("Could not quit plymouth: %s", error->message);
                 g_error_free (error);
         }
 }
 
 static void
 plymouth_quit_without_transition (void)
 {
         gboolean res;
         GError  *error;
 
         error = NULL;
         res = g_spawn_command_line_async ("/bin/plymouth quit", &error);
         if (! res) {
                 g_warning ("Could not quit plymouth: %s", error->message);
                 g_error_free (error);
         }
 }
 #endif
 
 #ifdef WITH_SYSTEMD
 static char *
 get_session_id_for_pid_systemd (pid_t    pid,
                                 GError **error)
 {
         char *session, *gsession;
         int ret;
 
         session = NULL;
-- 
2.3.3


From 2cbd7ad1f66d0a757c1d2217705436aa1beca76a Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Thu, 19 Mar 2015 22:38:15 -0400
Subject: [PATCH 2/2] manager: add a different hack to quit plymouth later

Right now wayland sessions register with GDM before they're
actually ready, so we quit plymouth too soon.

Until we can fix that, this commit quits plymouth when the login screen
connects to the daemon, or in the event of automatic login (where there
is no login screen), after 20 seconds.

This is like commit 862ba1bd67ec85b5784d3e8809a405f1845b1c43
but hopefully less broken..

https://bugzilla.gnome.org/show_bug.cgi?id=746498
---
 daemon/gdm-manager.c | 26 +++++++++++++++++++-------
 1 file changed, 19 insertions(+), 7 deletions(-)

diff --git a/daemon/gdm-manager.c b/daemon/gdm-manager.c
index 8c36e06..7b2cf65 100644
--- a/daemon/gdm-manager.c
+++ b/daemon/gdm-manager.c
@@ -155,72 +155,74 @@ plymouth_is_running (void)
         gboolean res;
         GError  *error;
 
         error = NULL;
         res = g_spawn_command_line_sync ("/bin/plymouth --ping",
                                          NULL, NULL, &status, &error);
         if (! res) {
                 g_debug ("Could not ping plymouth: %s", error->message);
                 g_error_free (error);
                 return FALSE;
         }
 
         return WIFEXITED (status) && WEXITSTATUS (status) == 0;
 }
 
 static void
 plymouth_prepare_for_transition (void)
 {
         gboolean res;
         GError  *error;
 
         error = NULL;
         res = g_spawn_command_line_sync ("/bin/plymouth deactivate",
                                          NULL, NULL, NULL, &error);
         if (! res) {
                 g_warning ("Could not deactivate plymouth: %s", error->message);
                 g_error_free (error);
         }
 }
 
-static void
+static gboolean
 plymouth_quit_with_transition (void)
 {
         gboolean res;
         GError  *error;
 
         error = NULL;
         res = g_spawn_command_line_async ("/bin/plymouth quit --retain-splash", &error);
         if (! res) {
                 g_warning ("Could not quit plymouth: %s", error->message);
                 g_error_free (error);
         }
+
+        return G_SOURCE_REMOVE;
 }
 
 static void
 plymouth_quit_without_transition (void)
 {
         gboolean res;
         GError  *error;
 
         error = NULL;
         res = g_spawn_command_line_async ("/bin/plymouth quit", &error);
         if (! res) {
                 g_warning ("Could not quit plymouth: %s", error->message);
                 g_error_free (error);
         }
 }
 #endif
 
 #ifdef WITH_SYSTEMD
 static char *
 get_session_id_for_pid_systemd (pid_t    pid,
                                 GError **error)
 {
         char *session, *gsession;
         int ret;
 
         session = NULL;
         ret = sd_pid_get_session (pid, &session);
         if (ret < 0) {
                 g_set_error (error,
                              GDM_DISPLAY_ERROR,
@@ -1707,66 +1709,60 @@ on_display_status_changed (GdmDisplay *display,
                       NULL);
         quit_plymouth = display_is_local && manager->priv->plymouth_is_running;
 #endif
 
         status = gdm_display_get_status (display);
 
         switch (status) {
                 case GDM_DISPLAY_PREPARED:
                 case GDM_DISPLAY_MANAGED:
                         if ((display_number == -1 && status == GDM_DISPLAY_PREPARED) ||
                             (display_number != -1 && status == GDM_DISPLAY_MANAGED)) {
                                 char *session_class;
 
                                 g_object_get (display,
                                               "session-class", &session_class,
                                               NULL);
                                 if (g_strcmp0 (session_class, "greeter") == 0) {
                                         gboolean will_autologin;
 
                                         will_autologin = display_should_autologin (manager, display);
 
                                         if (will_autologin) {
                                                 set_up_automatic_login_session (manager, display);
                                         } else {
                                                 set_up_greeter_session (manager, display);
                                         }
                                 }
                         }
 
                         if (status == GDM_DISPLAY_MANAGED) {
-#ifdef WITH_PLYMOUTH
-                                if (quit_plymouth) {
-                                        plymouth_quit_with_transition ();
-                                        manager->priv->plymouth_is_running = FALSE;
-                                }
-#endif
                                 greeter_display_started (manager, display);
                         }
                         break;
                 case GDM_DISPLAY_FAILED:
                 case GDM_DISPLAY_UNMANAGED:
                 case GDM_DISPLAY_FINISHED:
 #ifdef WITH_PLYMOUTH
                         if (quit_plymouth) {
                                 plymouth_quit_without_transition ();
                                 manager->priv->plymouth_is_running = FALSE;
                         }
 #endif
 
                         maybe_start_pending_initial_login (manager, display);
                         break;
                 default:
                         break;
         }
 
 }
 
 static void
 on_display_removed (GdmDisplayStore *display_store,
                     const char      *id,
                     GdmManager      *manager)
 {
         GdmDisplay *display;
 
         display = gdm_display_store_lookup (display_store, id);
         if (display != NULL) {
@@ -1972,60 +1968,69 @@ on_session_authentication_failed (GdmSession *session,
 {
         add_session_record (manager, session, conversation_pid, SESSION_RECORD_FAILED);
 }
 
 static void
 on_user_session_opened (GdmSession       *session,
                         const char       *service_name,
                         const char       *session_id,
                         GdmManager       *manager)
 {
         manager->priv->user_sessions = g_list_append (manager->priv->user_sessions,
                                                       g_object_ref (session));
         if (g_strcmp0 (service_name, "gdm-autologin") == 0 &&
             !gdm_session_client_is_connected (session)) {
                 /* If we're auto logging in then don't wait for the go-ahead from a greeter,
                  * (since there is no greeter) */
                 g_object_set_data (G_OBJECT (session), "start-when-ready", GINT_TO_POINTER (TRUE));
         }
 
         start_user_session_if_ready (manager, session, service_name);
 }
 
 static void
 on_user_session_started (GdmSession      *session,
                          const char      *service_name,
                          GPid             pid,
                          GdmManager      *manager)
 {
         g_debug ("GdmManager: session started %d", pid);
         add_session_record (manager, session, pid, SESSION_RECORD_LOGIN);
+
+#ifdef WITH_PLYMOUTH
+        if (g_strcmp0 (service_name, "gdm-autologin") == 0) {
+                if (manager->priv->plymouth_is_running) {
+                        g_timeout_add_seconds (20, (GSourceFunc) plymouth_quit_with_transition, NULL);
+                        manager->priv->plymouth_is_running = FALSE;
+                }
+        }
+#endif
 }
 
 static void
 remove_user_session (GdmManager *manager,
                      GdmSession *session)
 {
         GList *node;
         GdmDisplay *display;
 
         display = get_display_for_user_session (session);
 
         if (display != NULL) {
                 gdm_display_unmanage (display);
                 gdm_display_finish (display);
         }
 
         node = g_list_find (manager->priv->user_sessions, session);
 
         if (node != NULL) {
                 manager->priv->user_sessions = g_list_delete_link (manager->priv->user_sessions, node);
                 gdm_session_close (session);
                 g_object_unref (session);
         }
 }
 
 static void
 on_user_session_exited (GdmSession *session,
                         int         code,
                         GdmManager *manager)
 {
@@ -2141,60 +2146,67 @@ on_session_client_ready_for_session_to_start (GdmSession      *session,
 
         if (client_is_ready && waiting_to_start_user_session) {
                 start_user_session_if_ready (manager, session, service_name);
         }
 }
 
 static void
 on_session_client_connected (GdmSession      *session,
                              GCredentials    *credentials,
                              GPid             pid_of_client,
                              GdmManager      *manager)
 {
         GdmDisplay *display;
         char    *username;
         int      delay;
         gboolean enabled;
         gboolean allow_timed_login = FALSE;
 
         g_debug ("GdmManager: client connected");
 
         display = get_display_for_user_session (session);
 
         if (display == NULL) {
                 return;
         }
 
         if (!display_is_on_seat0 (display)) {
                 return;
         }
 
+#ifdef WITH_PLYMOUTH
+        if (manager->priv->plymouth_is_running) {
+                plymouth_quit_with_transition ();
+                manager->priv->plymouth_is_running = FALSE;
+        }
+#endif
+
         g_object_get (G_OBJECT (display), "allow-timed-login", &allow_timed_login, NULL);
 
         if (!allow_timed_login) {
                 return;
         }
 
         enabled = get_timed_login_details (manager, &username, &delay);
 
         if (! enabled) {
                 return;
         }
 
         gdm_session_set_timed_login_details (session, username, delay);
 
         g_free (username);
 
 }
 
 static void
 on_session_client_disconnected (GdmSession   *session,
                                 GCredentials *credentials,
                                 GPid          pid_of_client,
                                 GdmManager   *manager)
 {
         GdmDisplay *display;
         gboolean display_is_local;
 
         g_debug ("GdmManager: client disconnected");
 
         display = get_display_for_user_session (session);
-- 
2.3.3

